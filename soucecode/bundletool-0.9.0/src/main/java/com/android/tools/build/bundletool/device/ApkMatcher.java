/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License
 */

package com.android.tools.build.bundletool.device;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.ImmutableSet.toImmutableSet;

import com.android.bundle.Commands.ApkDescription;
import com.android.bundle.Commands.ApkSet;
import com.android.bundle.Commands.BuildApksResult;
import com.android.bundle.Commands.ModuleMetadata;
import com.android.bundle.Commands.Variant;
import com.android.bundle.Devices.DeviceSpec;
import com.android.bundle.Targeting.ApkTargeting;
import com.android.tools.build.bundletool.model.ModuleSplit;
import com.android.tools.build.bundletool.model.ZipPath;
import com.android.tools.build.bundletool.model.exceptions.CommandExecutionException;
import com.android.tools.build.bundletool.model.exceptions.ValidationException;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

/** Calculates whether a given device can be served an APK generated by the bundle tool. */
public class ApkMatcher {

  private final ImmutableList<? extends TargetingDimensionMatcher<?>> apkMatchers;

  private final Optional<ImmutableSet<String>> requestedModuleNames;
  private final boolean matchInstant;
  private final ModuleMatcher moduleMatcher;
  private final VariantMatcher variantMatcher;

  public ApkMatcher(DeviceSpec deviceSpec) {
    this(deviceSpec, Optional.empty(), /* matchInstant= */ false);
  }

  /**
   * Constructs an ApkMatcher, with a given device configuration, set of splits to match, and an
   * option to match instant splits.
   */
  public ApkMatcher(
      DeviceSpec deviceSpec,
      Optional<ImmutableSet<String>> requestedModuleNames,
      boolean matchInstant) {
    checkArgument(
        !requestedModuleNames.isPresent() || !requestedModuleNames.get().isEmpty(),
        "Set of requested split modules cannot be empty.");
    SdkVersionMatcher sdkVersionMatcher = new SdkVersionMatcher(deviceSpec);
    AbiMatcher abiMatcher = new AbiMatcher(deviceSpec);
    MultiAbiMatcher multiAbiMatcher = new MultiAbiMatcher(deviceSpec);
    ScreenDensityMatcher screenDensityMatcher = new ScreenDensityMatcher(deviceSpec);
    LanguageMatcher languageMatcher = new LanguageMatcher(deviceSpec);
    DeviceFeatureMatcher deviceFeatureMatcher = new DeviceFeatureMatcher(deviceSpec);

    this.apkMatchers =
        ImmutableList.of(
            sdkVersionMatcher, abiMatcher, multiAbiMatcher, screenDensityMatcher, languageMatcher);
    this.requestedModuleNames = requestedModuleNames;
    this.matchInstant = matchInstant;
    this.moduleMatcher = new ModuleMatcher(sdkVersionMatcher, deviceFeatureMatcher);
    this.variantMatcher =
        new VariantMatcher(
            sdkVersionMatcher, abiMatcher, multiAbiMatcher, screenDensityMatcher, matchInstant);
  }

  /**
   * Returns all APKs that should be installed on a device.
   *
   * @param buildApksResult describes APKs produced by the BundleTool
   * @return paths of the matching APKs as represented by {@link ApkDescription#getPath()}
   */
  public ImmutableList<ZipPath> getMatchingApks(BuildApksResult buildApksResult) {
    Optional<Variant> matchingVariant = variantMatcher.getMatchingVariant(buildApksResult);

    return matchingVariant.isPresent()
        ? getMatchingApksFromVariant(matchingVariant.get())
        : ImmutableList.of();
  }

  public ImmutableList<ZipPath> getMatchingApksFromVariant(Variant variant) {
    ImmutableList.Builder<ZipPath> matchedApksBuilder = ImmutableList.builder();

    Predicate<String> moduleNameMatcher = getModuleNameMatcher(variant);

    for (ApkSet apkSet : variant.getApkSetList()) {
      String moduleName = apkSet.getModuleMetadata().getName();

      for (ApkDescription apkDescription : apkSet.getApkDescriptionList()) {
        ApkTargeting apkTargeting = apkDescription.getTargeting();
        boolean isSplit =
            !apkDescription.hasStandaloneApkMetadata() && !apkDescription.hasApexApkMetadata();

        checkCompatibleWithApkTargeting(apkTargeting);

        if (matchesApk(apkTargeting, isSplit, moduleName, moduleNameMatcher)) {
          matchedApksBuilder.add(ZipPath.create(apkDescription.getPath()));
        }
      }
    }

    return matchedApksBuilder.build();
  }

  private Predicate<String> getModuleNameMatcher(Variant variant) {
    if (requestedModuleNames.isPresent()) {
      validateVariant(variant);

      ImmutableMultimap<String, String> moduleDependenciesMap = buildAdjacencyMap(variant);

      HashSet<String> dependencyModules = new HashSet<>(requestedModuleNames.get());
      for (String requestedModuleName : requestedModuleNames.get()) {
        addModuleDependencies(requestedModuleName, moduleDependenciesMap, dependencyModules);
      }

      if (matchInstant) {
        return dependencyModules::contains;
      } else {
        return Predicates.or(
            buildModulesDeliveredInstallTime(variant)::contains, dependencyModules::contains);
      }
    } else {
      if (matchInstant) {
        // For instant matching, by default all instant modules are matched.
        return Predicates.alwaysTrue();
      } else {
        // For conventional matching, only install-time modules are matched.
        return buildModulesDeliveredInstallTime(variant)::contains;
      }
    }
  }

  private void validateVariant(Variant variant) {
    if (requestedModuleNames.isPresent()) {
      Set<String> unknownModules =
          Sets.difference(
              requestedModuleNames.get(),
              variant
                  .getApkSetList()
                  .stream()
                  .map(ApkSet::getModuleMetadata)
                  .map(ModuleMetadata::getName)
                  .collect(toImmutableSet()));
      if (!unknownModules.isEmpty()) {
        throw ValidationException.builder()
            .withMessage(
                "The APK Set archive does not contain the following modules: %s", unknownModules)
            .build();
      }
    }
  }

  /** Builds a map of module dependencies. */
  private static ImmutableMultimap<String, String> buildAdjacencyMap(Variant variant) {
    ImmutableMultimap.Builder<String, String> moduleDependenciesMap = ImmutableMultimap.builder();
    variant
        .getApkSetList()
        .stream()
        .map(ApkSet::getModuleMetadata)
        .forEach(
            moduleMetadata -> {
              moduleDependenciesMap.putAll(
                  moduleMetadata.getName(), moduleMetadata.getDependenciesList());
              moduleDependenciesMap.put(moduleMetadata.getName(), "base");
            });
    return moduleDependenciesMap.build();
  }

  /** Builds a list of modules that will be delivered on installation. */
  private ImmutableSet<String> buildModulesDeliveredInstallTime(Variant variant) {
    // Module dependency resolution can be skipped because install-time modules can't depend on
    // on-demand modules.
    return variant.getApkSetList().stream()
        .map(ApkSet::getModuleMetadata)
        .filter(this::willBeDeliveredInstallTime)
        .map(ModuleMetadata::getName)
        .collect(toImmutableSet());
  }

  private boolean willBeDeliveredInstallTime(ModuleMetadata moduleMetadata) {
    return !moduleMetadata.getOnDemand()
        && moduleMatcher.matchesModuleTargeting(moduleMetadata.getTargeting());
  }

  /** Adds module dependencies to {@code dependencyModules}. */
  private static void addModuleDependencies(
      String moduleName,
      Multimap<String, String> moduleDependenciesMap,
      Set<String> dependencyModules) {
    if (!moduleDependenciesMap.containsKey(moduleName)) {
      return;
    }

    for (String moduleDependency : moduleDependenciesMap.get(moduleName)) {
      // We do not examine again the dependency that was previously handled and added.
      if (dependencyModules.add(moduleDependency)) {
        addModuleDependencies(moduleDependency, moduleDependenciesMap, dependencyModules);
      }
    }
  }

  /** Returns whether a given APK generated by the Bundle Tool should be installed on a device. */
  private boolean matchesApk(
      ApkTargeting apkTargeting,
      boolean isSplit,
      String moduleName,
      Predicate<String> moduleNameMatcher) {
    boolean matchesTargeting = matchesApkTargeting(apkTargeting);

    if (isSplit) {
      return matchesTargeting && moduleNameMatcher.test(moduleName);
    } else {
      if (matchesTargeting && requestedModuleNames.isPresent()) {
        throw CommandExecutionException.builder()
            .withMessage("Cannot restrict modules when the device matches a non-split APK.")
            .build();
      }
      return matchesTargeting;
    }
  }

  private boolean matchesApkTargeting(ApkTargeting apkTargeting) {
    return apkMatchers.stream()
        .allMatch(matcher -> matcher.getApkTargetingPredicate().test(apkTargeting));
  }

  /**
   * Returns whether a given APK generated by the Bundle Tool matches the device targeting.
   *
   * @return whether the APK matches the device targeting
   */
  public boolean matchesModuleSplitByTargeting(ModuleSplit moduleSplit) {
    // Check device compatibility.
    variantMatcher.checkCompatibleWithVariantTargeting(moduleSplit.getVariantTargeting());
    checkCompatibleWithApkTargeting(moduleSplit.getApkTargeting());

    return variantMatcher.matchesVariantTargeting(moduleSplit.getVariantTargeting())
        && matchesApkTargeting(moduleSplit.getApkTargeting());
  }

  private void checkCompatibleWithApkTargeting(ApkTargeting apkTargeting) {
    apkMatchers.forEach(matcher -> checkCompatibleWithApkTargetingHelper(matcher, apkTargeting));
  }

  private <T> void checkCompatibleWithApkTargetingHelper(
      TargetingDimensionMatcher<T> matcher, ApkTargeting apkTargeting) {
    matcher.checkDeviceCompatible(matcher.getTargetingValue(apkTargeting));
  }

}
